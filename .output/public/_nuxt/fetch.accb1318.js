import{h as O}from"./Link.fb4a2cb7.js";import{c2 as k,j as w,b1 as E,b8 as R,aB as j,aK as x,m as A,bY as B,c3 as F,g as T,ab as M,i as U,ba as p,r as $,c4 as z}from"./entry.2e60e461.js";function H(...r){var g;const u=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(u);let[a,o,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=B(),f=()=>null,m=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??f,e.getCachedData=e.getCachedData??m,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??k.deep;const h=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(g=t.payload._errors)[a]??(g[a]=null);const i=e.deep?w:E;t._asyncData[a]={data:i(e.getCachedData(a)??e.default()),pending:w(!h()),error:R(t.payload._errors,a),status:w("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(i={})=>{if(t._asyncDataPromises[a]){if(i.dedupe===!1)return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&h())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const l=new Promise((n,c)=>{try{n(o(t))}catch(_){c(_)}}).then(n=>{if(l.cancelled)return t._asyncDataPromises[a];let c=n;e.transform&&(c=e.transform(n)),e.pick&&(c=L(c,e.pick)),t.payload.data[a]=c,s.data.value=c,s.error.value=null,s.status.value="success"}).catch(n=>{if(l.cancelled)return t._asyncDataPromises[a];s.error.value=F(n),s.data.value=T(e.default()),s.status.value="error"}).finally(()=>{l.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=l,t._asyncDataPromises[a]};const D=()=>s.refresh({_initial:!0}),b=e.server!==!1&&t.payload.serverRendered;{const i=M();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const n=i._nuxtOnBeforeMountCbs;i&&(j(()=>{n.forEach(c=>{c()}),n.splice(0,n.length)}),x(()=>n.splice(0,n.length)))}b&&t.isHydrating&&(s.error.value||h())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(D):e.immediate&&D(),e.watch&&A(e.watch,()=>s.refresh());const l=t.hook("app:data:refresh",async n=>{(!n||n.includes(a))&&await s.refresh()});i&&x(l)}const v=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(v,s),v}function L(r,u){const a={};for(const o of u)a[o]=r[o];return a}function N(r,u,a){const[o={},e]=typeof u=="string"?[{},u]:[u,a],t=U(()=>{let y=r;return typeof y=="function"&&(y=y()),p(y)}),f=o.key||O([e,typeof t.value=="string"?t.value:"",...q(o)]);if(!f||typeof f!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+f);if(!r)throw new Error("[nuxt] [useFetch] request is missing.");const m=f===e?"$f"+f:f;if(!o.baseURL&&typeof t.value=="string"&&t.value.startsWith("//"))throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:h,lazy:s,default:D,transform:b,pick:v,watch:g,immediate:i,getCachedData:l,deep:n,...c}=o,_=$({...z,...c,cache:typeof o.cache=="boolean"?void 0:o.cache}),P={server:h,lazy:s,default:D,transform:b,pick:v,immediate:i,getCachedData:l,deep:n,watch:g===!1?[]:[_,t,...g||[]]};let d;return H(m,()=>{var C;(C=d==null?void 0:d.abort)==null||C.call(d),d=typeof AbortController<"u"?new AbortController:{};const y=p(o.timeout);return y&&setTimeout(()=>d.abort(),y),(o.$fetch||globalThis.$fetch)(t.value,{signal:d.signal,..._})},P)}function q(r){var a;const u=[((a=p(r.method))==null?void 0:a.toUpperCase())||"GET",p(r.baseURL)];for(const o of[r.params||r.query]){const e=p(o);if(!e)continue;const t={},f=Array.isArray(e)?e:Object.entries(e);for(const[m,h]of f)t[p(m)]=p(h);u.push(t)}return u}export{N as u};
